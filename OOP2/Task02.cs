namespace OOP2
{
    class Task02
    {
    }
}
/*
 * ЗАДАНИЕ 4
 * Open/Closed Principle говорит нам о том, что любой модуль должен быть открыт для расширения, но закрыт для изменений.
 * Открыт для расширения по сути любой класс в ООП-языке, если он не закрыт для наследования модификатором final/sealed
 * Закрытым класс является тогда, когда он спроектирован таким образом, что при изменении других классов, которые он использует,
 * не придется переписывать его код.
 * Например, у нас есть класс для вывода периметра переданной ему фигуры. Предположим, ранее передавались только многоугольники,
 * периметр которых равен сумме длин всех сторон, собственно так периметр и высчитывался. Но что, если этому классу передать круг?
 * Принцип закрытости указывает нам, что сам класс фигуры должен считать свой периметр, тогда наш выводящий класс будет просто вызывать соотвествующий метод.
 *
 *
 * ЗАДАНИЕ 5
 * В C# используются следующие принципы:
 * 1. Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики);
 *  -- как раз Generics
 *
 * 2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу;
 *  -- методы класса
 *
 * 3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля;
 *  -- namespaces
 *
 * 4. Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) -- например,
 * реализация обобщённого типа для конкретного типа-параметра;
 *  -- видимо, тут речь идет об overloading, типа sum (int a, int b) и sum(double a, double b)
 *
 * 5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.
 *  -- не уверен, что понял вопрос, но интегрировать поведение нескольких модулей в C# можно с помощью интерфейсов, так как в C# нет множественного наследования.
 *
 * ЗАДАНИЕ 6
 * Существуют ли ситуации, когда связи между модулями должны делаться публичными?
 *  -- конечно каждый модуль делается отдельным и максимально независимым от других модулей, но такие ситуации существуют, например, если у нас есть классы
 *  разных странспортных средств и есть класс, который, например, красит любое транспортное средство. но такие связи надо делать как можно более слабыми, например
 *  через интерфейсы
 *
 * Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
 *  -- количество модулей и количество связей между модулями
 *
 * Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам?
 *  -- если в программе всего 3-5 классов, то я, наверное, смотрел бы размер самих классов, не слишком ли они большие, на связи между классами и на иерархию,
 *  не слишком ли она глубокая получилась
 */
